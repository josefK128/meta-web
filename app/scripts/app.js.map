{"version":3,"names":[],"mappings":"","sources":["app.js"],"sourcesContent":["// * app.js\n// * central module for angular components<br>\n// * configures providers and runs initial set-up\n// * manages metastate system for url-specified compiled template:model view\n//   component updates animation and cinematography\n// * NOTE: url = scene/i3d(webgl)/i2d(svg)/base(html)/ui/shot\n//\n// * @dependency 'ui-router' - state-based routing<br>\n//   @dependency 'ui-grid' - ui and table interface to data (future apps)<br>\n//   @dependency param services, config <br>\n//   @param {ui.router.state.$stateProvider} $stateProvider<br>\n//   @param {ui.router.router.$urlRouterProvider} $urlRouterProvider<br>\n//   @param {ng.$locationProvider} $locationProvider<br>\n//   @param {ui.router.state.$state} $state<br>\n//   @param {ng.$rootScope} $templateCache <br>\n//   @param {ng.$rootScope} $compile <br>\n//   @param {ng.$rootScope} $timeout<br>\n//   @param {ng.$rootScope} $rootScope<br>\n//   @param {services/models-service} Models<br>\n//   @param {services/camera3d-service} Camera3d<br>\n//   @param {services/mediator-service} Mediator<br>\n//   @param {services/log-service} Log<br>\n//   @param {services/mockserver-service} Mockserver<br>\n//   @param {app/services/mixin-service} Mixin<br>\n//   @param {app/services/transform3d-service} Transform3d<br>\n//   @param {index.html} Angular object value 'config'<br>\n//   @ngInject\n//\n// * NOTE: Mixin and Transform3d are injected only for possible unit testing\n//\n// * NOTE: @ngInject is used by ngAnnotate to generate a \n//   minification-safe injection annotation such as:\n//   ```function($scope) => ['$scope', function($scope){}]```\n//\n// * NOTE: app.js also implements a MutationObserver system of DOM watch for changes \n//   in selected properties and children. However at present it is not used<br>\n//   Preferred is a direct interaction with i3d-components within the canvas \n//   'singularity' since it is faster and simpler than a two-level event-watch \n//   system<br>\n//   However i3d-components are initially created declaratively via angular directives \n//   using svg-templates compiled into the DOM using associated JSON models.<br>\n//   These i3d actors are then later animated and modified by direct access since the\n//   webgl objects are accessible by DOM id from an object hierarchy managed by\n//   Camera3d\n\n\nangular.module(\"app\", ['ui.router', 'ui.grid'])\n  .config([\"$stateProvider\", \"$urlRouterProvider\", \"$locationProvider\", function($stateProvider, $urlRouterProvider, $locationProvider){\n    'use strict'; \n\n\n    // $locationProvider<br>\n    // enable use of html5Mode urls and browser history api\n    $locationProvider.html5Mode({\n      enabled: true,\n      requireBase: false,\n      rewriteLinks: false\n    });\n\n\n    // $urlRouterProvider<br>\n    // application state-change via url\n    $urlRouterProvider.otherwise('/');\n\n\n    // $stateProvider<br>\n    // association of templates and models with the six components of application\n    // state:<br>\n    // * scene\n    // * i3d\n    // * i2d\n    // * base(html/css)\n    // * ui(html)\n    // * shot(cinematography, animation and generative dynamics)<br>\n    //\n    // * NOTE: url has form: {scene}/{i3d}/{i2d}/{base}/{ui}/{shot} where each\n    //   component is a template-model pair<br><br>\n    //\n    // * NOTE: initial unnamed state has the following implicit properties:\n    // ```.state('', {\n    //   url: '^',\n    //   template: 'index.html',\n    //   abstract: true\n    // })```\n    //\n    // * NOTE: templateUrl takes one preset param stateParams - not injected\n    //\n    // * NOTE: ```metastate.onEnter``` will only be called during the first and all\n    //   subsequent url changes, and not during the initial rendering of index.html<br>\n    //   thus a reference to narrative component-controller will be available from \n    //   Mediator for each state-change - critical because all models are placed\n    //   on the parent narrative scope.<br>\n    var metastate = {\n      url: '^/{scene}/{i3d}/{i2d}/{base}/{ui}/{shot}',\n      onEnter: () => {\n        var delta_params = metastate.stateObj.delta_params,\n            scope,\n            name,\n            tuple,\n            template,\n            model,\n            template_view,\n            shot,\n            Camera3d,\n            narrative,\n            node;    // named node(s) in shot model\n\n        // fetch reference to narrative component controller-scope\n        narrative = metastate.narrative || \n          metastate.Mediator.component('narrative');\n\n        // narrative has method to return reference to its scope<br>\n        // this scope is used when compiling all dynamic templates since\n        // it contains all models\n        scope = scope || narrative.scope();\n \n        // Camera3d\n        Camera3d = Camera3d || metastate.Camera3d;\n\n   \n        // delta templates/models\n        for(let p of Object.keys(delta_params)){\n          if(delta_params[p].length > 0){\n            name = delta_params[p];\n            tuple = name.split(\":\");\n            template = tuple[0] || \"\";\n            model = tuple[1] || \"\";\n\n            switch(p){\n              case 'scene':\n                // at present scene is used only to display scene-name at the\n                // start of the url<br>\n                // The scene-model is reserved for possible future uses\n                // such as audio and/or dialogue\n                break;\n\n              case 'i3d':\n\n                // fetch the template_view from the cache\n                template_view = metastate.cache.get(`${template}.svg`);\n\n                // make model available on narrative component scope \n                scope.i3d = metastate.Models.get('i3d', template, model) || {};\n                //for(let p of Object.keys(scope.i3d)){\n                //}\n\n                // change i3d template_view and webgl scene\n                // * NOTE: optionally can pass in procedurally created scene\n                Camera3d.changeTemplateScene(template);\n\n                // replace content of '#i3d' template-view container with the\n                // template_view fetched from the cache\n                $(\"#i3d\").html(template_view);\n\n                // compile the template_view and all contained directives\n                // using the model (which is attached at scope.i3d)\n                metastate.compile($(\"#i3d\").contents())(scope);\n                break;\n\n              case 'i2d':\n\n                // fetch the template_view from the cache\n                template_view = metastate.cache.get(`${template}.svg`);\n\n                // make model available on narrative component scope \n                scope.i2d = metastate.Models.get('i2d', template, model) || {};\n                //for(let p of Object.keys(scope.i2d)){\n                //}\n\n                // replace content of '#i2d' template_view container with the\n                // template_view fetched from the cache\n                $(\"#i2d\").html(template_view);\n                \n                // compile the template_view and all contained directives\n                // using the model (which is attached at scope.i2d)\n                metastate.compile($(\"#i2d\").contents())(scope);\n                break;\n\n              case 'base':\n\n                // fetch the template_view from the cache\n                template_view = metastate.cache.get(`${template}.html`);\n\n                // make model available on narrative component scope \n                scope.base = metastate.Models.get('base',template,model) || {};\n\n                // shot\n                scope.shot = scope.shot || {};\n\n                // replace content of '#base' template_view container with the \n                // template_view fetched from the cache\n                $(\"#base\").html(template_view);\n\n                // compile the template_view and all contained directives\n                // using the model (which is attached at scope.base)\n                metastate.compile($(\"#base\").contents())(scope);\n                break;\n\n              case 'ui':\n\n                // fetch the template_view from the cache\n                template_view = metastate.cache.get(`${template}.html`);\n\n                // make model available on narrative component scope \n                scope.ui = metastate.Models.get('ui', template, model) || {};\n                // shot\n                scope.shot = scope.shot || {};\n\n                // replace content of '#ui' template_view container with the\n                // template_view fetched from the cache\n                $(\"#ui\").html(template_view);\n\n                // compile the template_view and all contained directives\n                // using the model (which is attached at scope.ui)\n                metastate.compile($(\"#ui\").contents())(scope);\n                break;\n\n              case 'shot':\n\n                // fetch the template_view from the cache\n                template_view = metastate.cache.get(`${template}.svg`);\n\n                // check the shot-model name:<br>\n                // If it is 'scope' then narrative has already written the model\n                // to scope.shot<br> \n                // If not then fetch the model from Models and place it on\n                // scope.shot - if no model then set scope.shot = {}<br>\n                if(!/^scope/.test(model)){\n                  scope.shot = metastate.Models.get('shot', template, model) || {};\n                }else{\n                  scope.shot = scope.shot || {};\n                }\n\n\n                // process each grafted branch at indicated existing parent\n                // scope.shot = shot.template.model = {branch0,...} (object)\n                let delta = scope.shot.delta || {};\n                //console.dir(scope.shot.delta);\n\n                let branches = delta.branches || {};\n                //console.dir(delta.branches);\n\n                // iterate through parents upon which to graft each branch\n                for(let p of Object.keys(branches)){\n                  node = $(`#${p}`);  // i3d-svg-DOM element\n\n                  // add the template_view to the i3d-svgDOM for angular\n                  // compilation by action of directives in the template<br>\n                  node.append(template_view);\n\n                  metastate.compile(node.contents())(scope);\n                }//branches\n\n                // * NOTE: graft-parent transforms and timeline animation\n                //   is executed in narrative $stateChangeSuccess event-handler \n                //   to allow selection of t-direction (fwd/back)<br>\n                //   back => timeline.reverse(),else fwd by timeline.play()\n                break;\n\n              default:\n            }\n          }//changed state components\n        }//state components\n      }//onEnter()\n    };//metastate\n\n    $stateProvider\n    .state('delta', metastate);  \n  }]) //config\n\n\n  // * narrative-component directive is linked and only after app.run, \n  //   so all services and values needed by ``metastate.onEnter```` must be \n  //   placed on // metastate to be accessed.<br> \n  //   Narrative (and hence its scope) can be obtained from Mediator.<br>\n  // * Recall that all component controllers register a named reference with \n  //   Mediator  \n  // * Recall also that narrative has a method scope() which returns its scope\n  .run([\"$state\", \"$templateCache\", \"$location\", \"$compile\", \"$timeout\", \"$rootScope\", \"Models\", \"Camera3d\", \"Mediator\", \"Log\", \"Mockserver\", \"Mixin\", \"Transform3d\", \"config\", function($state, $templateCache, $location, $compile, $timeout, \n    $rootScope, Models, Camera3d, Mediator, Log, Mockserver, Mixin, Transform3d, \n    config) {\n    'use strict';\n\n    var observer;\n\n  \n    // make $templateCache $location $rootScope $compile $timout $rootScope, \n    // Models Mixin Camera3d and Mediator accessible to single state \n    // 'delta' stateConfig object metastate\n    var metastate =$state.get('delta');\n    metastate.cache = $templateCache;\n    metastate.location = $location;\n    metastate.compile = $compile;\n    metastate.timeout = $timeout;\n    metastate.Models = Models;\n    metastate.Camera3d = Camera3d;\n    metastate.Mediator = Mediator;\n    metastate.Log = Log;\n    metastate.config = config;\n\n\n    // set up Mutation Observer on media DOM (i2d/i3d branches of 'zoom_plane')\n    // which takes an options object arg containing DOM change handler and\n    // one or more queries specifying elements and attributes to observer\n    // and the rootNode DOM 'branch' to watch - zoom_plane is media-DOM root \n    observer = new MutationSummary({\n      queries: [{attribute: 'transform'}, {attribute: 'form'}], \n      //{attribute: 'children'}]; - not used\n      rootNode: document.getElementById('i3d'),\n      callback : (summaries) => {\n        var dtransform = summaries[0],\n            dform = summaries[1],\n            actor,\n            delta = [],\n            m = new THREE.Matrix4(),\n            mr,\n            mt,\n            ms,\n            k;\n\n\n        // delta-transform\n        for(let node of dtransform.valueChanged){\n\n          // current value of node.transform - transform\n          let transform = JSON.parse(node.getAttribute('transform'));\n\n          // previous value of node.form - formp\n          let transformp = JSON.parse(dtransform.getOldAttribute(node, \n            'transform'));\n\n          // actor\n          actor = Camera3d.actor(node.id);\n\n          // execute transform changes on webgl actor\n          for(let p of Object.keys(transform)){\n            if(!angular.equals(transform[p], transformp[p])){\n              delta.push({property: p,\n                          previous: transformp[p],\n                          current: transform[p]});\n            }\n          }\n\n          // transform matrix component matrices\n          for(k=0; k<delta.length; k++){\n            let p = delta[k]['property'];\n            if(p === 't'){\n              let ta = delta[k]['current'];\n              for(let i=0; i<ta.length; i++){\n              }\n              mt = (new THREE.Matrix4()).makeTranslation(ta[0],ta[1],ta[2]);\n            }\n            if(p === 'q'){\n              let qa = delta[k]['current'];\n              for(let i=0; i<qa.length; i++){\n              }\n              let q = new THREE.Quaternion(qa[0],qa[1],qa[2],qa[3]);\n              mr = (new THREE.Matrix4()).makeRotationFromQuaternion(q);\n            }\n            if(p === 'e'){\n              let ea = delta[k]['current'];\n              for(let i=0; i<ea.length; i++){\n              }\n              let euler = new THREE.Euler(ea[0],ea[1],ea[2]);//default pyr (xyz)\n              let q = (new THREE.Quaternion()).setFromEuler(euler);\n              mr = (new THREE.Matrix4()).makeRotationFromEuler(euler);\n            }\n            if(p === 's'){\n              let sa = delta[k]['current'];\n              for(let i=0; i<sa.length; i++){\n              }\n              ms = (new THREE.Matrix4()).makeScale(sa[0],sa[1],sa[2]);\n            }\n          }//delta[k]\n    \n          // transform matrix - first scale, then rotate, then translate\n          m = mt || m;\n          if(mr){\n            m = m.multiply(mr);\n          }\n          if(ms){\n            m = m.multiply(ms);\n          }\n\n          // transform actor in webgl scene\n          actor.applyMatrix(m);\n        }//dtransform.valueChanged()\n\n\n        // delta-form\n        for(let node of dform.valueChanged){\n\n          // current value of node.transform - transform\n          //let form = node.getAttribute('form');\n\n          // previous value of node.form - formp\n          //let formp = dform.getOldAttribute(node, 'form');\n\n          // @TODO\n          // use component controllers to modify webgl actor form properties\n          // NOTE: this may mean remaking a Material!\n        }//dform.valueChanged\n      }//callback\n    });//MutationSummary\n\n    \n\n    // * connect to server (if required).\n    // * Server logs e2e cell data (action; abs_url; delta_url; shot)\n    //   and possibly records the action stream (config.record_stream) \n    //   and also possibly records the interactive-keyboard camera shots \n    //   (config.record_shots)\n    // * If server is started with non-empty argv[2] ($node index <any char>)\n    //   then the server is expected to broadcast a performance action-sequence\n    if(config.server_connect){\n      Mediator.connect();\n    }\n\n\n    // * unit_test and/or e2e_test.\n    // * Listen for alt-3 - possibly start unit test followed by possible \n    //   Mockserver start if unit tests all pass, or possible e2e_test by itself.\n    // * Mockserver broadcasts (rehearsal) performance actions and/or e2e test. \n    window.addEventListener(\"keyup\", function(e){\n      switch(e.keyCode){\n\n        // start score-timeline action sequence broadcast<br>\n        // alt 3 => start\n        case 51: \n          if(e.altKey){\n            if(config.unit_test){\n              console.log(\"starting unit tests...\");\n              config.unit_spec(Mediator, Mixin, Transform3d, Camera3d, config).then(() => {\n                if(config.mockserver_connect){\n                  console.log(\"starting Mockserver...\");\n                  Mockserver.start();\n                  config.mockserver_connect = false;\n                }\n              }).catch((e) => {\n                console.log(`unit tests failed: ${e}`);\n                console.log(\"skipping e2e test...\");\n              });\n            }else{\n              if(config.mockserver_connect){\n                console.log(\"starting Mockserver...\");\n                Mockserver.start();\n                config.mockserver_connect = false;\n              }\n            }\n          }\n          break;\n\n        default:\n      }\n   });\n\n  }]);// run\n"],"file":"app.js","sourceRoot":"/source/"}