{"version":3,"names":[],"mappings":"","sources":["components/i3d/i3d-ground-directive.js"],"sourcesContent":["// * i3d-ground-directive.js\n// * creates three.js component registered with Camera3d and added to scene\n// * pass in params as attrs\n//\n// * @dependencies: Camera3d, Transform3d<br>\n//   @param {services/camera3d-service.js} Camera3d<br>\n//   @param {services/transform3d-service.js} Transform3d<br>\n//   @param {services/log-service.js} Log<br>\n//   @param {utils/colourToHex.js} colourToHex<br>\n//   @ngInject\n//\n// * NOTE: ngInject is used by ngAnnotate to generate a \n//   minification-safe injection annotation such as:\n//   ```function($scope) => ['$scope', function($scope){}]```\n//\n// * NOTE:uses shaders ShaderMaterial to texture three.js PlaneBufferedGeometry\n// * NOTE: Camera3d.addActorToScene(pid, id, node) adds the node as a child to \n//   Camera3d.actor[pid] if pid is defined,\n//   and as a child of webgl scene otherwise (i.e. if root)\n// * NOTE: all work constructing the node (THREE.js Object3d) is done in pre-link\n//   function since pre-links are run after controller constructor and in\n//   root-to-leaf order so that correct relative transforms are computed in webgl\n//   RECALL: link-fs (===post-link-fs) are run in leaf-to-root order!! \n// * NOTE: controller must use services for $scope $element and $attrs whereas\n//   pre-link (and post-link) receive these three args (in order) as well as\n//   a fourth arg instance of the controller\n// * NOTE: $destroy occurs when the angular jQuery wrapper is destroyed.\n//   Thus the wrapper is removed from the DOM but not the 'raw' DOM element\n//   nor, more importantly, the webgl node in the underlying webgl scenegraph\n\n\nangular.module('app').directive(\"i3dGround\", [\"Camera3d\", \"Transform3d\", \"Log\", \"colourToHex\", function(Camera3d, \n  Transform3d, Log, colourToHex){\n  \"use strict\";\n\n\n  // return DDO\n  return {\n    restrict: 'E',\n    scope: 'true',\n    replace: 'false',\n    templateNamespace: 'svg',\n    compile: function(elem, attrs){\n\n\n      // vars used by pre-link-f and (trivially) by post-link-f\n      // * NOTE attrs  are all strings! - for safety must convert values<br>\n      //   strings do NOT work as boolean values in Material for exp.<br>\n      //   objects form and transform must converted by ```JSON.parse```\n      var form,\n      w,h,\n      textureurl,\n      color,\n      transparent,\n      wireframe,\n      opacity,\n      planeGeometry,\n      shaderMaterial,\n      planeMaterial,\n      basic_material = () => {\n\n        // basic material\n        planeMaterial = new THREE.MeshBasicMaterial({color: color, \n           transparent: transparent, opacity: opacity });\n        // three.js blending<br>\n        // * NOTE! - brightening of opaque image intersections \n        //   sometimes occurs (?!)\n        //   This should NOT occur with the following:<br>\n        //   planeMaterial.blendDst = THREE.OneMinusSrcAlphaFactor;\n        // * NOTE! brightening does occur with:\n        //   planeMaterial.blendDst = THREE.DstAlphaFactor;\n        //\n        planeMaterial.depthTest = false;\n        planeMaterial.blending = THREE.CustomBlending;\n        planeMaterial.blendSrc = THREE.SrcAlphaFactor;\n        //planeMaterial.blendDst = THREE.DstAlphaFactor;\n        planeMaterial.blendDst = THREE.OneMinusSrcAlphaFactor;\n        planeMaterial.blendEquation = THREE.AddEquation; // default\n      },\n\n      texture_material = (texture) => {  \n        // filters\n        texture.magFilter = THREE.LinearFilter;\n        texture.minFilter = THREE.LinearMipMapLinearFilter;\n    \n        // assuming you want the texture to repeat in both directions:<br>\n        // how many times to repeat in each direction - default is (1,1),\n        texture.wrapS = THREE.RepeatWrapping; \n        texture.wrapT = THREE.RepeatWrapping;\n          \n        // shaderMaterial<br>\n        // = new THREE.MeshLambertMaterial({ map : texture });<br>\n        // color is defined by one float (!?) => f f f ? so 1.0 => white ?\n        shaderMaterial = new THREE.ShaderMaterial({ \n          uniforms: {\n            color: {type: 'f', value: 1.0},\n            map: {type: 't', value: texture}\n          },\n          vertexShader: document.getElementById(\"vsh.glsl\").text,\n          fragmentShader: document.getElementById(\"fsh.glsl\").text,\n          transparent: true\n        });\n\n        // three.js blending<br>\n        // * NOTE! - brightening of opaque image intersections \n        //   sometimes occurs (?!)\n        //   This should NOT occur with the following:<br>\n        //   shaderMaterial.blendDst = THREE.OneMinusSrcAlphaFactor;\n        // * NOTE! brightening does occur with:\n        //   shaderMaterial.blendDst = THREE.DstAlphaFactor;\n        //\n        //shaderMaterial.depthTest = false;\n        //shaderMaterial.blending = THREE.CustomBlending;\n        shaderMaterial.blendSrc = THREE.SrcAlphaFactor; // default\n        //shaderMaterial.blendDst = THREE.DstAlphaFactor;\n        shaderMaterial.blendDst = THREE.OneMinusSrcAlphaFactor; // default\n        shaderMaterial.blendEquation = THREE.AddEquation; // default\n\n        // material\n        planeMaterial = shaderMaterial;\n      }, //texture_material\n\n      realize = (id, pid, transform) => {\n        // create a webgl plane-node\n        var node = new THREE.Mesh(planeGeometry, planeMaterial);\n        node.material.side = THREE.DoubleSide;\n\n        // rotate the plane to comprise XZ plane\n        node.rotation.x=-0.5*Math.PI;\n      \n        // add the Object3d to the scene and store in Camera3d actors by id\n        Camera3d.addActorToScene(id, node, pid);\n  \n        // transform ground - relative to parent in THREE.js scene !!!\n        Transform3d.apply(transform, node);\n      },\n\n\n      //pre-link runs root-to-leaf\n      prelink = (scope, elem, attrs) => {\n  \n        // NOTE! attrs are all strings! - convert via JSON.parse!   \n        // pid is 'parent-id'\n        var id = attrs.id,\n            p = scope.p || {},\n            pid = p.pid,\n            transform,\n            texture;\n  \n        // clear and set $scope.p.pid = id for subsequent children<br>\n        // $scope.p is a different object for each level \n        scope.p = {};\n        scope.p.pid = id;\n  \n  \n        // evaluations/defaults\n        form = JSON.parse(attrs.form || '{}');\n        w = form.w || 20.0;\n        h = form.h || 20.0;\n        color = form.color || 'green';\n        wireframe = form.wireframe || false;\n        textureurl = form.textureurl; // no textureurl => color, no texture\n        transparent = form.transparent || true;\n        opacity = form.opacity || 1.0;\n        transform = JSON.parse(attrs.transform || '{}');\n  \n\n        // convert color name to hex for use in three.js material\n        if(!/^(#|0x)/.test(color)){\n          color = colourToHex(color);\n        }\n  \n\n        // geometry - optimized using webGL buffers\n        planeGeometry = new THREE.PlaneBufferGeometry(w,h,1,1); \n  \n  \n        // material<br>\n        // texture map => ShaderMaterial<br>\n        /*\n        .loadTexture (url, mapping, onLoad, onError)\n          url -- the url of the texture\n          mapping -- Can be an instance of THREE.UVMapping, \n            THREE.CubeReflectionMapping, \n            THREE.SphericalReflectionMapping, or \n            THREE.SphericalRefractionMapping. \n            Describes how the image is applied to the object.\n            Use undefined instead of null as a default value. \n            See mapping property of texture for more details. \n          onLoad -- callback function\n          onError -- callback function\n        */\n        if(textureurl){\n\n          //match =>  textureurl is a cached THREE.js texture with same name<br>\n          //no-match => textureul is a relative url for http load\n          if(/(_png|_jpg|_gif|_bmp)/.test(textureurl)){\n            // if texture is found use it - else use color<br>\n            // * NOTE: when using preloaded cached textures no http load\n            //   is attempted - this is CRITICAL to maintaining root-to-leaf\n            //   adding of actors to the webgl tree (following pre-link order)\n            //   so relative transforms are correctly applied in the hierarchy\n            // * NOTE: use window[textureurl] which converts string to var name\n            //   of a THREE.js texture\n            if(textureurl){\n              texture_material(window[textureurl]);\n            }else{\n              basic_material();\n            }\n            // realize in webgl\n            realize(id, pid, transform);\n          }else{\n            texture = THREE.ImageUtils.loadTexture(textureurl, \n              THREE.UVMapping, function(){       \n                 texture_material(texture);\n                 // realize in webgl\n                 realize(id, pid, transform);\n            }, \n            null,  // onProgress()\n            function(){  // onError() - use basic_material - color\n              basic_material();\n              // realize in webgl\n              realize(id, pid, transform);\n            });//loadTexture\n          }\n        }else{\n          // no textureurl - BasicMeshMaterial\n          basic_material();\n          realize(id, pid, transform);\n        }//if-textureurl\n\n        // cleanup\n        elem.on(\"$destroy\", function() {\n          //Camera3d.removeActorFromScene(id);\n          //scope = null;\n        });\n\n      },//pre-link runs root-to-leaf\n      //post-link runs leaf-to-root\n      postlink =  (scope, elem, attrs) => {\n      };//post-link\n      // vars\n  \n\n\n\n      // compile returns link={pre,post}\n      return {\n        pre: prelink,\n        post: postlink\n      };\n    }//compile\n  };//return DDO\n}]);\n\n"],"file":"components/i3d/i3d-ground-directive.js","sourceRoot":"/source/"}