{"version":3,"names":[],"mappings":"","sources":["components/mw-narrative-directive.js"],"sourcesContent":["// * mw-narrative-directive\n// * dynamic meta-controller for state management by url and url-components\n//   which are descriptors used to compile independent template:model views\n//   for each of six url components:\n// * url = ```scene/i3d/i2d/base/ui/shot```<br>\n//   where scene is a hierarchical name and carries media meta-information, \n//   i3d is webgl, i2d is svg, base and ui are html, and shot is scene dynamics \n//   such as cinematography animation and scene additions and modifications<br> \n//   Each component is a template:model pair (although a model is not strictly\n//   required)\n// * narrative also manages the browser history and the UI controls\n//   all in a synchronized and dynamic manner\n//\n// * @dependencies: $state, $location, param services and config<br>\n//   @param {angular.$rootScope} $rootScope<br>\n//   @param {ui.router.state.$state} $state<br>\n//   @param {angular.$location} $location<br>\n//   @param {angular.$templateCache} $templateCache<br>\n//   @param {angular.$timeout} $timeout<br>\n//   @param {angular.$compile} $compile<br>\n//   @param {services/mediator-service} Mediator<br>\n//   @param {services/models-service} Models<br>\n//   @param {services/camera3d-service} Camera3d<br>\n//   @param {services/camera2d-service} Camera2d<br>\n//   @param {services/log-service} Log<br>\n//   @param {GSAP} TweenMax<br>\n//   @param {GSAP} TimelineMax<br>\n//   @param {GSAP} Quad<br>\n//   @param {created in index.html initialization script} config<br>\n//   @ngInject\n//\n// * NOTE: ngInject is used by ngAnnotate to generate a \n//   minification-safe injection annotation such as:\n//   ```function($scope) => ['$scope', function($scope){}]```\n//\n// * narrative provides a subset of functional entry points to a 'pipeline' of\n//   url generation and modifications. Action messages can execute these\n//   functions to modify application state by change to one or more of the url\n//   components.<br>\n//   These pipeline entry points are:\n//     * shot(shot-template-name:JSON-model) or shot(shot-template-name:model-name)\n//     * change_scene(scene-name)\n//     * change_state(absolute-url) or change_state(delta-url)\n//     * NOTE: $location.url(url) is the final change of url and state and\n//       changes the address in the browser address bar (which is also the\n//       current state of history). It is used internally ONLY\n// * NOTE: narrative detects two bound events:\n//     * $locationChangeSuccess - updates a stateObj and state sequence \n//     * $stateChangeSuccess - executes associated timeline animations and\n//       dynamics\n// * NOTE: narrative initializes Camera2d and Camera3d and passes to them (and others) \n//   references to narrative, narrative scope for access to models, \n//   and Mediator for access to components and websocket communications\n\n\nangular.module('app').directive('mwNarrative', \n  [\"$rootScope\", \"$state\", \"$location\", \"$templateCache\", \"$timeout\", \"$compile\", \"Mediator\", \"Models\", \"Camera3d\", \"Camera2d\", \"Log\", \"TweenMax\", \"TimelineMax\", \"Quad\", \"config\", function($rootScope, $state, $location, $templateCache, $timeout, $compile, \n    Mediator, Models, Camera3d, Camera2d, Log, TweenMax, TimelineMax, Quad, \n    config) {\n  'use strict';\n\n\n  // auxilliary utility function - calculate delta_params, the url components\n  // which have changed from one absolute url to another\n  var delta = (abs_params, abs_paramsp) => {\n    var delta_params = {};\n\n    for(let p of Object.keys(abs_params)){\n      if(abs_paramsp[p] !== abs_params[p]){\n        delta_params[p] = abs_params[p];\n      }else{\n        delta_params[p] = \"\";\n      }\n    }\n    return delta_params;\n  };\n\n  // closure vars for e2e tests\n  var urls_index = 0,\n      urls_failed = 0,\n      shot_index = 0,\n      shot_failed = 0;\n\n\n\n\n\n\n  // class declarations are not hoisted so place them at the top in case of\n  // possible extends expression, for exp. (not used in this system)<br>\n  // Placement inside the angular registration function prevents global name clash<br>\n  // The ES6 class is provided as a partial bridge to a possible future\n  // implementation in Angular 2.x or in some other components framework<br>\n  // * NOTE: prototypes are the underlying more simple and elegant delegation\n  //   method but classes work fairly well - in some cases services or other\n  //   prototype instances must be declared as closure variables rather than\n  //   instance variables of a component class instance. This is in order to\n  //   force the use of the  proper execution context ('this') for correct\n  //   operation of the service or object instance. This mismatch of execution\n  //   context intention is the cause of errors which do not occur in either\n  //   pure class systems or pure prototype systems - see notes at specific closure\n  //   variable declarations. It is good to remember that 'class' is a useful\n  //   syntax but not a true Class.\n  // * NOTE: the class 'Narrative' provides the constructor for the component used\n  //   for injection \n  // * NOTE: constructors are run from root-to-leaf and then link-fs are run leaf-to-root\n  // * NOTE: bindToController double-bound (\"=\") attributes are\n  //   initially set to the child scope controller ctor value since the\n  //   child scope controller is run after the parent scope controller.\n  //   However, if the double-bound attributes are (also) set in the link-fs,\n  //   the parent link-f is run last so becomes the set attribute value\n  class Narrative {\n    constructor(){\n\n      // ui \n      this.scenes = Object.keys(config.scenes);     \n      this.controls = Object.keys(config.controls);\n      // ui - stored in stateObj\n      this.scene =  config.opening_scene;          \n      this.control_state = config.controls;\n\n      // this.terms = Object.keys(this.scene)\n      const terms = ['scene', 'i3d', 'i2d', 'base', 'ui', 'shot']; \n      this.terms = terms; \n\n      // flag to regulate processing in the $locationChangeSuccess handler<br>\n      // true => process back/fwd;<br> \n      // false => jump over back/fwd processing<br>\n      // ```this.backfwd``` set to false in change_state() because that method is not\n      // attained by back-fwd; ```this.backfwd``` is set to true at end of url-change\n      // in the $stateChangeSuccess handler for the next url<br>\n      // frame is an ordered index for stateObjs - it is used to determine if a\n      // back-fwd url change is back or forward - by order comparison to the\n      // previous frame index\n      // * NOTE: fwd implies that the shot animation timeline is played forward\n      // in time, and back implies that it is reversed in time\n      this.backfwd = false;\n      this.frame = 0;\n\n      // prev_url saves the present url for various comparisons to (present) url<br> \n      // sequence is a hash with url keys and frame index values ordered \n      // by time of creation - used to detect back or forward button press\n      this.sequence = {};\n      this.prev_url = '^';             // delta\n      this.back = false;\n\n      // history stateObj - persistent\n      // * NOTE: abs_params and delta_params each use the constant keys found in\n      //   ```this.terms``` array: 'scene', 'i3d', 'i2d', 'base', 'ui' and 'shot'\n      // * NOTE: abs_params  is the set of six component values found in the tail of the\n      //   address bar url following the 'app/'<br>\n      //   Similarly delta_params are the components of the relative url 'tail'\n      //   which have changed from the previous state's url with \"\" representing\n      //   the unchanged components.\n      // * By tail is meant ```<adress bar url>.replace(/.*app\\//, \"\");```\n      // * NOTE: config.initial_url is an example of a relative url 'tail'\n      this.stateObjp = {};\n      this.stateObjp['abs_url'] = '^';\n      this.stateObjp['delta_url'] = '^';\n      this.stateObj = {};\n      this.stateObj['scene'] = this.scene;\n      this.stateObj['control_state'] = this.control_state;\n      this.stateObj['delta_url'] = config.initial_url;\n      this.stateObj['abs_url'] = config.initial_url;\n      this.stateObj['delta_params'] = config.scenes[this.scene];\n      this.stateObj['abs_params'] = config.scenes[this.scene];\n      this.sequence[config.initial_url] = this.frame;\n      this.sequence[this.prev_url] = this.frame - 1;\n      this.sequence[this.frame] = this.stateObj;\n      this.sequence[this.frame - 1] = this.stateObjp;\n\n      // metastate - stateConfig of single 'delta' state\n      this.metastate = $state.get('delta');\n\n      // initial metastate.stateObj/stateObjp\n      this.metastate.stateObj = this.stateObj;\n      this.metastate.stateObjp = this.stateObjp;\n      \n      // initial store of stateObj uses ```config.initial_url``` as initial url\n      // * NOTE: this.stateObj['abs_url'] = config.initial_url which is a full\n      //   url-components expansion so provides an information 'bootstrap' about\n      //   what is playing in the first state-scene<br>.       \n      //   This permits component 'set changes' and dynamic camera shots to be \n      //   applied to the opening scene\n      history.replaceState(this.stateObj, this.scene);\n\n      // TEMP! - test bindToController for ui-msgbg\n      if(this.stateObj.abs_params['ui'].match(/ui-msgbg/)){\n        this.test();\n      }\n\n      // NOTE: e.state is this.stateObj for some state\n      window.addEventListener('popstate', (e) => {\n      });\n\n\n\n      $rootScope.$on('$locationChangeSuccess', (e) => {\n        var url = $location.url(),\n            popped_url,\n            abs_paramsp,\n            abs_params,\n            delta_params = {},\n            delta_url = '',\n            d_url = '',\n            abs_url = '',\n            a_url = '',\n            d_passed = true,\n            a_passed = true;\n\n\n        // ignore first locationChangeSucess which is start-up with url = '/'\n        // log all url-state changes - except initial.\n        // (possibly) e2e-test all url changes - except initial.\n        // absolute = stateObj['abs_url'] and delta = $location(url)\n        // {2,3} log abs_url, delta_url - for building e2e_spec array\n        if(!/^\\/$/.test(url)){\n          Log.log(`${this.stateObj['abs_url']}`);\n          Log.log(`${url}`);\n\n          // *** e2e urls test\n          if(config.e2e_test){\n            // delta_url\n            d_url = config.e2e_spec[urls_index].delta_url;\n            delta_url = url; // $location.url()\n            if(!check.primitive(delta_url)){\n              delta_url = delta_url.valueOf();  // make primitive if not already\n            }\n  \n            // abs_url\n            a_url = config.e2e_spec[urls_index].abs_url;\n            abs_url = this.stateObj.abs_url;\n            if(!check.primitive(abs_url)){\n              abs_url = abs_url.valueOf();  // make primitive if not already\n            }\n  \n            // primitive strings are equal (===) by value, not ref\n            // delta_url\n            if(delta_url !== d_url){\n              d_passed = false;\n              console.log(`e2e_spec[${urls_index}] delta_url test failed: result:${delta_url} !== expected:${d_url}`);\n              Log.log(`e2e_spec[${urls_index}] delta_url test failed: result:${delta_url} !== expected:${d_url}`);\n            }\n  \n            // abs_url\n            if(abs_url !== a_url){\n              a_passed = false;\n              console.log(`e2e_spec[${urls_index}] abs_url test failed: result:${abs_url} !== expected${a_url}`);\n              Log.log(`e2e_spec[${urls_index}] abs_url test failed: result:${abs_url} !== expected:${a_url}`);\n            }\n  \n            // score\n            if(!d_passed || !a_passed){\n              urls_failed++;\n            }\n  \n            // prepare for next state-change e2e urls test\n            urls_index++;\n  \n            // report e2e result\n            if(urls_index === config.e2e_spec.length){\n              console.log(`*** e2e action->state-change-urls comparison test: \n                                   ${config.e2e_spec.length} tests  \n                                   ${urls_failed} failures ***`); \n              Log.log(`*** e2e urls test: ${config.e2e_spec.length} tests  ${urls_failed} failures ***`); \n            }\n          }\n        }//avoid initial url change ('/')\n\n\n        // if $locationChangeSuccess generated by back or fwd button\n        if(this.backfwd){\n\n          // this.stateObjp\n          this.stateObjp = this.sequence[this.frame];\n\n          if(this.sequence[url] < this.sequence[this.prev_url]){\n            this.back = true;\n            this.frame -= 1;\n          }else{\n            this.back = false;\n            this.frame += 1;\n          }\n\n          // this.stateObj\n          this.stateObj = this.sequence[this.frame];\n\n          // set metastate\n          this.metastate.stateObj = this.stateObj;\n          this.metastate.stateObjp = this.stateObjp;\n          \n          // recalculate this.metastate.delta_params and \n          // this.metastate.delta_url to correspond to change from the \n          // 'next' state instead of change from the 'previous' state\n          // as originally calculated\n          abs_paramsp = this.metastate.stateObjp.abs_params;\n          abs_params = this.metastate.stateObj.abs_params;\n          delta_params = delta(abs_params, abs_paramsp);\n          for(let p of terms){\n            delta_url += `/${delta_params[p]}`;\n          }\n          this.metastate.stateObj.delta_params = delta_params;   \n          this.metastate.stateObj.delta_url = delta_url;   \n          \n          // sync this.stateObj \n          this.stateObj = this.metastate.stateObj;\n          \n          // set scene for ui\n          $timeout(() => {\n            $rootScope.$apply(() => {\n              this.scene = this.stateObj.scene;\n              this.scope().ui.scene = this.scene;\n            });\n          });\n        }else{\n          this.back = false;\n        }\n\n        // if not initial url '/' - identify malformed url\n        if(!/^\\/$/.test(url)){\n          if(/^(\\/.*){6}$/.test(url)){\n          }else{\n            console.log(`!Narrative.onLocChSucc(url = ${url} is NOT well-formed`);\n            Log.log({t:'!Narrative', f:'onLocChSucc', a:`url ${url} is NOT well-formed`});\n          }\n        }\n        \n        // TEMP! - test bindToController for ui-msgbg\n        if(this.stateObj.abs_params['ui'].match(/ui-msgbg/)){\n          this.test();\n        }\n      });\n\n\n\n      $rootScope.$on('$stateChangeSuccess', (e) => {\n        var shot,\n            _shot,\n            expected_shot,\n            _scope,\n            delta,\n            branches,\n            node,\n            tl,\n            timeline = (_delta) => {\n              var _timeline = _delta.timeline || {},\n                  tlp = _timeline.p || {},\n                  actors = _timeline.actors || {},\n                  actions = _timeline.actions || [],\n                  ntuple,\n                  type,\n                  id,\n                  p,\n                  target,  // target obj for property to be tweened - animated\n                  tweens,\n                  i;\n\n\n              // timeline ctor params - tlp\n              tlp.paused = tlp.paused || true; // default\n              tlp.tweens = tlp.tweens || [];\n              \n\n              // iterate through actors on which one or more tweens are defined\n              for(let a of Object.keys(actors)){\n                ntuple = a.split(':');\n                type = ntuple[0];\n                id = ntuple[1];\n                if(!type){\n                  continue;\n                }\n                if(!id){\n                  continue;\n                }\n                ntuple = ntuple.slice(2); \n                i=0;\n                for(let q of ntuple){\n                  i++;\n                }\n\n                // set target of tween\n                if(type === 'i3d'){\n                  target = Camera3d.actor(id);\n                }else{\n                  target = document.getElementById(id);\n                }\n                if(!target){\n                  continue;\n                }\n                if(ntuple.length > 0){\n                  for(let q of ntuple){\n                    if(q){\n                      target = target[q];\n                    }\n                  }\n                }\n                if(!target){\n                  continue;\n                }\n\n                // insert tween defaults if not specified<br>\n                // add tweens to tlp.tweens array\n                tweens = actors[a];\n                for(let tween of tweens){\n                  // dur - duration of the tween animation\n                  if(tween.dur === undefined){\n                    tween.dur = 10;\n                  }\n                  // p - properties of the target object which are to be tweened\n                  tween.p.delay = tween.p.delay || 0;\n                  tween.p.ease = tween.p.ease || Quad.easeInOut;\n                  // actions\n                  if(tween.actions){\n                    if(tween.actions.start){\n                      tween.p.onStart = Mediator.exec;\n                      tween.p.onStartParams = tween.actions.start;\n                    }\n                    if(tween.actions.update){\n                      tween.p.onUpdate = Mediator.exec;\n                      tween.p.onUpdateParams = tween.actions.update;\n                    }\n                    if(tween.actions.complete){\n                      tween.p.onComplete = Mediator.exec;\n                      tween.p.onCompleteParams = tween.actions.complete;\n                    }\n                    if(tween.actions.start){\n                      tween.p.onReverseComplete = Mediator.exec;\n                      tween.p.onReverseCompleteParams = tween.actions.reverse_complete;\n                    }\n                  }\n                  tlp.tweens.push(TweenMax.to(target, tween.dur, tween.p));\n                }\n              }//actors\n\n\n              // add callback function(s) to tlp \n              if(actions){\n                if(actions.start){\n                  tlp.onStart = Mediator.exec;\n                  tlp.onStartParams = actions.start;\n                }\n                if(actions.update){\n                  tlp.onUpdate = Mediator.exec;\n                  tlp.onUpdateParams = actions.update;\n                }\n                if(actions.complete){\n                  tlp.onComplete = Mediator.exec;\n                  tlp.onCompleteParams = actions.complete;\n                }\n                if(actions.reverseComplete){\n                  tlp.onReverseComplete = Mediator.exec;\n                  tlp.onReverseCompleteParams = actions.reverseComplete;\n                }\n              }\n              // add Mediator.next() to onComplete\n              // force Mediator.next - overwrite if needed\n              tlp.onComplete = Mediator.exec;\n              tlp.onReverseComplete = Mediator.exec;\n              tlp.onCompleteParams = actions.complete || [];\n              tlp.onCompleteParams.push({t: 'mediator', f:'queue_ready_next'});\n              tlp.onReverseCompleteParams = actions.reverseComplete || [];\n              tlp.onReverseCompleteParams.push({t: 'mediator', f:'queue_ready_next'});\n\n              // return primed timeline\n              return new TimelineMax(tlp);\n            };//timeline() \n            \n\n        // update urls\n        this.prev_url = $location.url();\n\n        // set to trigger back-fwd processing - turned off in change_state\n        // if no back/fwd button press\n        this.backfwd = true;\n\n\n        // *** e2e shot-test\n        // convert shot objects to JSON-strings and ensure they are primitives\n        if(config.e2e_test){\n\n          // prepare\n          shot = JSON.stringify(this.scope().shot || {});\n          if(!check.primitive(shot)){\n            console.log(`!JSON.stringify(shot) not primitive - index ${shot_index}`);\n            Log.log(`!JSON.stringify(shot) not primitive - index ${shot_index}`);\n            shot = shot.valueOf();\n          }\n          expected_shot = JSON.stringify(config.e2e_spec[shot_index].shot);\n          if(!check.primitive(expected_shot)){\n            console.log(`!JSON.stringify(expected_shot) not primitive - index ${shot_index}`);\n            Log.log(`!JSON.stringify(expected_shot) not primitive - index ${shot_index}`);\n            expected_shot = expected_shot.valueOf();\n          }\n          // test\n          if(shot !== expected_shot){\n            shot_failed++;\n            console.log(`e2e_spec[${shot_index}] shot test failed: result:${shot} !== expected:${expected_shot}`);\n            Log.log(`e2e_spec[${shot_index}] shot test failed: result:${shot} !== expected:${expected_shot}`);\n          }\n          \n          // prepare for next e2e shot test\n          shot_index++;\n\n          // report e2e result\n          if(shot_index === config.e2e_spec.length){\n            console.log(`*** e2e shot->scope.shot models comparison test: \n                             ${config.e2e_spec.length} tests  \n                             ${shot_failed} failures ***`); \n            Log.log(`*** e2e shot test: ${config.e2e_spec.length} tests ${shot_failed} failures ***`); \n          }\n        }\n\n\n        // possible grafts and animations in shot model\n        // if no chnage in shot this.scope().shot is undefined\n        //prev: delta = this.scope().shot.delta || {};\n        _scope = this.scope() || {};\n        _shot = _scope.shot || {};\n        \n\n        // {4} log abs_url, delta_url - for building e2e_spec array\n        Log.log(_shot);\n\n\n        // timeline - acts on base, i3d and/or i2d actors\n        delta = _shot.delta || {};\n        tl = timeline(delta);\n\n        // timeline - if back - run anim in reverse, else forward\n        if(this.back === true){\n          tl.seek(tl.duration());\n          tl.reverse();\n        }else{\n          tl.play();\n        }\n      });\n    }//ctor\n\n\n\n    // narrative instance methods:<br>\n    // diagnostic feedback monitoring of $templateCache\n    onload(msg){\n      if(msg.match(/templates.html/)){\n      }\n    }\n\n\n\n    // manage control changes and UI in a synchronized manner\n    change_control(control){ \n\n      // 'csph' is camaerasphere<br>\n      // lights (attached to camerasphere) consist of \n      // defaults - 'key', 'fill' and 'back'\n      switch(control){\n        case 'HOME':\n          Camera3d.home({d:3});\n          $timeout(() => {\n            $timeout(() => {\n              $rootScope.$apply(() => {\n                this.control_state['HOME'] = false;\n              });\n            }, 3000);\n          });\n          // log action\n          Log.log({\"t\":\"camera3d\", \"f\":\"home\", \"a\":{\"d\":3}});\n          break;\n\n        case 'CNTR':\n          Camera3d.center({d:3});\n          $timeout(() => {\n            $timeout(() => {\n              $rootScope.$apply(() => {\n                this.control_state['CNTR'] = false;\n              });\n            }, 3000);\n          });\n          // log action\n          Log.log({\"t\":\"camera3d\", \"f\":\"center\", \"a\":{\"d\":3}});\n          break;\n\n        case 'csph':\n          if(Camera3d.csphere()){\n            let b = this.control_state['csph'];\n            Camera3d.toggle_csphere({name:'csph', val:b});\n            // log action\n            Log.log({\"t\":\"camera3d\", \"f\":\"toggle_csphere\", \"a\":b}); \n          }else{\n            // revert to prev state of control\n            $timeout(() => {\n              $rootScope.$apply(() => {\n                this.control_state['csph'] = !this.control_state['csph'];\n              });\n            });\n          }\n          break;\n\n        case 'key':\n        case 'fill':\n        case 'back':\n          if(Camera3d.light(control)){\n            let b = this.control_state[control];\n            Camera3d.toggle_light({name:control, val:b});\n            // log action\n            Log.log({\"t\":\"camera3d\", \"f\":\"toggle_light\", \"a\":b}); \n          }else{\n            // revert to prev state of control\n            $timeout(() => {\n              $rootScope.$apply(() => {\n                this.control_state[control] = !this.control_state[control];\n              });\n            });\n          }\n          break;\n\n        default: \n          console.log(`!unknown control name = ${control}`); \n      }\n    }\n\n\n    // shot<br>\n    // shot = 'template-name':JSON-model or 'template-name':'model-name'<br>\n    // shot is converted to an abs_url for eventual invocation of \n    // ```change_state(abs_url)```\n    shot(shot){\n      var abs_url_components, \n          abs_url='/',\n          i=0;\n\n      // guard - non-empty string\n      if(!check.unemptyString(shot)){\n        console.log(`!Narrative.shot(shot = ${shot}) Not unempty string)`);\n        return;\n      }\n      // guard - has form template-name:JSON or template-name:model-name\n      if(!/:/.test(shot)){\n        console.log(`!Narrative.shot(shot = ${shot}) NOT well-formed)`);\n        return;\n      }\n\n      Mediator.queue.ready = false;\n      abs_url_components = this.stateObj.abs_url.split('/'); \n      abs_url_components.pop();\n      if(abs_url_components[0] === ''){\n        abs_url_components.shift();\n      }\n\n      for(let c of abs_url_components){\n        abs_url += `${c}/`;\n      }\n      abs_url += shot;\n\n      // if shot is json embed json model into scope and rename model to:\n      // ```'scope'${frame}``` - exp: JSON model -> 'scope27'<br>\n      // The JSON is parsed to a model object and written to \n      // ```narrative.scope().shot```<br>\n      // The keyword 'scope' in the url shot component alerts the metastate \n      // processor in app.js that the shot model is already on the scope \n      // so need not be fetched from Models<br>\n      this.change_shot(abs_url);\n    }\n      \n\n    // change_scene_by_ui(scene){\n    // allows logging of action before calling change_scene\n    // NOTE: this cannot be done in change_scene since change_scene may have\n    // been invoked by a non-UI action such as a studio score performance,\n    // and consequently a change_scene action would have already been logged.\n    change_scene_by_ui(scene){\n      Log.log({\"t\":\"narrative\", \"f\":\"change_scene\", \"a\":scene});\n      this.change_scene(scene);\n    }\n\n    // change scene<br>\n    // builds absolute url from scene components given for the scene in\n    // config.<br> \n    change_scene(scene){\n      var abs_values = [],\n          abs_params = {},\n          abs_url,\n          i = 0;\n\n      // guard - non-empty string\n      if(!check.unemptyString(scene)){\n        console.log(`!Narrative.change_scene(scene = ${scene} - Not unempty string)`);\n        return;\n      }\n      // guard - scene among config.scenes\n      // technique using check-more-types.js\n      if(!check.oneOf(Object.keys(config.scenes), scene)){\n        console.log(`!Narrative.change_scene(scene = ${scene} - Not in config.scenes)`);\n        return;\n      }\n      // technique using check-types.js\n//      if(check.any(check.apply(Object.keys(config.scenes), (s) => {\n//        s === scene.valueOf();\n//      }))){\n//        console.log(`!Narrative.change_scene(scene = ${scene} - Not in config.scenes)`);\n//      return;\n//      }\n\n\n      // if scene is changed by action-msg rather than UI - sync UI via this.scene\n      if(scene !== this.scene){\n        $timeout(() => {\n          $rootScope.$apply(() => {\n            this.scene = scene; // change UI if change is by action-message\n          });\n        });\n        this.scene = scene; // change narrative property now for further analysis\n\n      }\n\n      // if scene is not previous url scene get params state and urls\n      if(this.scene !== this.stateObj.scene){\n\n        // this.abs_params, abs_values\n        abs_params = config.scenes[this.scene];\n//        for(let p of this.terms){\n//        }\n        // abs_values\n        for(let p of this.terms){\n          abs_values[i++] = abs_params[p];\n        }\n\n        // urls\n        abs_url = '/';\n        abs_url += abs_values.join('/');\n\n        // if shot is json embed json model into scope and rename model to:\n        // ```'scope'${frame}``` - exp: JSON model -> 'scope27'<br>\n        // The JSON is parsed to a model object and written to \n        // ```narrative.scope().shot```<br>\n        // The keyword 'scope' in the url shot component alerts the metastate \n        // processor in app.js that the shot model is already on the scope \n        // so need not be fetched from Models<br>\n        this.change_shot(abs_url);\n      }\n    }\n\n\n    // change_shot<br>\n    // * simplifies url and then calls ```change_state(simplified-url)```:\n    //   * replace JSON-string shot-model in url by string 'scope'+frame-number\n    //   * parse the JSON to an object 'model' and set ```scope.shot = model```\n    //   * call change_state(url) with the simpler url.\n    // * NOTE: the use of JSON-model shots permits dynamic shot cinematography \n    //   not requiring the model to pre-exist in the Models service cache\n    change_shot(url){\n      var tuple = url.split('shot'),\n          shot = [],\n          template,\n          model;\n\n      // guard - non-empty string\n      if(!check.unemptyString(url)){\n        console.log(`!Narrative.change_shot(url = ${url} - Not unempty string)`);\n        return;\n      }\n \n      tuple[1] = 'shot' + tuple[1];\n      shot = tuple[1].split(/:(.*)/) || \"\";\n  \n      template = shot[0] || \"\";\n      model = tuple[1].split(/:(.*)?/)[1] || \"\";\n\n  \n      if(!/^{/.test(model)){\n        this.change_state(url);\n      }else{  \n        // process url\n        model = JSON.parse(model);\n        this.scope().shot = model;\n  \n        // new url\n        url = tuple[0] + template + ':scope' + this.frame;\n        this.change_state(url);\n      }\n    }\n\n\n    // change state via $urlRouterProvider and $location.url(this.delta_url)\n    change_state(url){\n      var params = {},\n          values = [],\n          abs_params = {},\n          abs_values = [],\n          delta_values = [],\n          i = 0;\n\n      // guard - non-empty string\n      if(!check.unemptyString(url)){\n        console.log(`!Narrative.change_state(url = ${url} - Not unempty string)`);\n        return;\n      }\n      \n      // guard - convert trailing '/' (undefined shot) to 'shot-fixed:'\n      if(/\\/$/.test(url)){\n        url = url + 'shot-fixed:';\n      }\n      \n      // guard - replace 'shot-fixed:{}' by non-JSON equivalent 'shot-fixed:'\n      // guard - replace incorrect shot '{}' by 'shot-fixed:'\n      if(/shot-fixed:\\{}$/.test(url)){\n        url = url.replace(/\\{}$/, \"\");\n      }else{\n        if(/\\{}$/.test(url)){\n          url = url.replace(/\\{}$/, \"shot-fixed:\");\n        }\n      }\n\n\n      // guard - should NOT contain JSON - removed previously by change_shot()\n      // or guards\n      if(/\\{/.test(url)){\n        console.log(`!Narrative.change_state(url = ${url} - contains JSON - returning)`);\n        return;\n      }\n\n\n      // init new this.stateObj\n      this.stateObj = {};\n      this.stateObj.abs_params = {};\n      this.stateObj.delta_params = {};\n      this.frame += 1;\n      this.stateObj.frame = this.frame;\n\n\n      // params from url components; copy of metastate.stateObj.abs_params\n      values = url.slice(1).split('/');\n      for(let p of this.terms){\n        params[p] = values[i];\n        i+=1;\n      }\n\n      // this.stateObj.abs_params\n      abs_params = this.metastate.stateObj.abs_params;\n      i = 0;\n      for(let p of this.terms){\n        this.stateObj.delta_params[p] = \"\"; // initial\n        abs_values[i] = \"\";                 // initial\n        if(params[p].length > 1){\n          this.stateObj.abs_params[p] = params[p];\n          abs_values[i] = params[p];\n        }else{\n          this.stateObj.abs_params[p] = abs_params[p];\n          abs_values[i] = abs_params[p];\n        }\n        i += 1;\n      }\n\n      // this.stateObj.delta_params\n      i = 0;\n      this.stateObj.delta_params = {};\n      for(let p of this.terms){\n        this.stateObj.delta_params[p] = \"\";  // initial\n        delta_values[i] = \"\";                // initial\n        i += 1;\n      }\n      i = 0;\n      for(let p of this.terms){\n        if(params[p].length > 0){\n          if(params[p] !== abs_params[p]){\n            this.stateObj.delta_params[p] = params[p];\n            delta_values[i] = params[p];\n          }\n        }  \n        i+=1;\n      }\n\n      // this.stateObj.scene, this.stateObj.abs_url, this.stateObj.delta_url\n      this.stateObj.scene = this.stateObj.abs_params['scene'].split(\":\")[0]; \n      this.stateObj.abs_url = '/';\n      this.stateObj.delta_url = '/';\n      this.stateObj.abs_url += abs_values.join('/');\n      this.stateObj.delta_url += delta_values.join('/');\n      this.stateObj.control_state = this.control_state;\n\n      // set scene for ui\n      $timeout(() => {\n        $rootScope.$apply(() => {\n          this.scene = this.stateObj.scene;\n          this.scope().ui.scene = this.scene;\n        });\n      });\n\n      // diagnostics\n\n      // metastate\n      this.metastate.stateObjp = this.metastate.stateObj;\n      this.metastate.stateObj = this.stateObj;\n\n      // change state via url<br>\n      // skip back-fwd processing in $locationChangeSuccess handler\n      this.backfwd = false;\n      this.sequence[this.stateObj.delta_url] = this.frame;\n      this.sequence[this.frame] = this.stateObj;\n      //  ${this.sequence[this.stateObj.delta_url]}`);\n      //  ${this.sequence[this.frame].abs_url}`);\n\n      // trigger state change\n      $location.url(this.stateObj.delta_url);\n\n      // load current stateObj - no url update is needed\n      history.replaceState(this.stateObj, this.scene); \n    }\n\n\n    // TEMP!: expt-test of bindToController{ bgcolor: '=' }\n    test(){\n      // if ui-msgbg is used in index.html narrative link-f will not have\n      // been called yet - so this.scope() and scope will be undefined<br>\n      // these alternatives place ui and ui.bgcolor on narrative instead\n      // and then set scope = narrative (this) iff this.scope() is undefined\n      var scope = (this.scope ? this.scope() : this);\n      scope.ui = {};\n      scope.ui.bgcolor='black';      \n      scope.ui.scene = this.scene;      \n//      if(scope === this){\n//      }else{\n//      }\n\n      $timeout(function(){\n        $rootScope.$apply(function(){\n          scope.ui.bgcolor = 'red';\n        });\n      }, 1000);\n\n      $timeout(function(){\n        $rootScope.$apply(function(){\n          scope.ui.bgcolor = 'blue';\n        });\n      }, 3000);\n    }//test\n  }\n\n\n  // return factory object DDO\n  return {\n    restrict: 'EA',   // attribute preferred for use in <body>\n    // to use bindToController scope must be created so must be \n    // isolated ({}) or child (true)\n    scope: true,    \n    controller: Narrative,      // instance of class-ctor Narrative \n    controllerAs: 'narrative',  // standard name for component ctrl instance\n\n    // binds specified scope-references used by template properties<br>\n    // use same name in template parent controller and child controller<br>\n    // '=' => properties are 'double-bound' between controllers and template<br>\n    // '@' => parent properties are written to the template'<br> \n    //        but there is no sync between controllers p->ch or ch->p\n    bindToController: true,\n\n    // link-f unused except for diagnostics\n    link(scope, el, attrs, narrative){\n\n      var _scope = scope;\n\n      // method to get scope reference - crucially important!\n      // * NOTE: scope is needed by metastate processor in app.js\n      //   to compile all dynamic templates\n      narrative.scope = () => {\n        return _scope;  // available via closure\n      };\n\n      Mediator.component(\"narrative\", narrative);\n\n\n      // initialize Cameras (once) and pass in narrative.scope (critical!)<br> \n      // Also set refs to narrative and mediator - crucial!\n      Camera2d.place(scope);\n      Camera2d.set_narrative(narrative);\n      Camera2d.set_mediator(Mediator); // also set in Mediator\n\n\n      // initialize Camera3d (once) - pass in scope<br>\n      // * arg0 = id of canvas3d\n      // * arg1 = name of template_view (and model)\n      // * arg2 = narrative.scope (critical!)\n      // * [arg3] = (optional) reference to procedurally pre-created Three.js \n      //   scene loaded by index.html script and output as var 'Scene' \n      Camera3d.place(config.canvas3d,\n                     config.scenes[config.opening_scene]['i3d'],\n                     _scope,\n                     config.Scene);  // temp - opening 3D scene\n\n      // Also set refs to narrative mediator - crucial!\n      Camera3d.set_narrative(narrative);\n      Camera3d.set_mediator(Mediator); // also set in Mediator\n    }//link-f\n  };//return DDO\n}]);\n"],"file":"components/mw-narrative-directive.js","sourceRoot":"/source/"}