{"version":3,"names":[],"mappings":"","sources":["services/mediator-service.js"],"sourcesContent":["// mediator-service.js \n// central communications registration and look-up service for all \n// component-directives controllers\n// Also manages websocket (socketio) communications with server\n//\n// @dependencies: params services, config\n// @param {angular.$rootScope} $rootScope \n// @param {angular.$location} $location   \n// @param {'./scripts/services/queue-service'} Queue\n// @param {'./scripts/services/camera3d-service'} Camera3d\n// @param {'./scripts/services/camera2d-service'} Camera2d\n// @param {'./scripts/services/models-service'} Models\n// @param {'./scripts/services/mixin-service'} Mixin\n// @param {'./scripts/services/log-service'} Log\n// @param {index.html} Angular object value 'config'\n// @ngInject\n//\n// NOTE: ngInject is used by ngAnnotate to generate a \n// minification-safe injection annotation such as:\n// function($scope) => ['$scope', function($scope){}]\n//\n// NOTE: Mediator expects action-objects of form:\n// var action = {t: 'target',  ('narrative','camera3d','camera2d',...)\n//               <OR>\n//               id: Camera3d.actor(id) or doc.getElById(id)\n//               <AND>\n//               f: 'function'\n//               a: '{}/[]/value'  // args\n// Then action is executed as follows:\n// Mediator[t][f](a);\n// <OR>\n// Camera3d['actor'](id)[f](a);\n//\n// NOTE: A further dynamic methodology is implemented but not presently used.\n// example: broadcast\n// var action = {id: Actor3d/Actor2d.actor(id) (Actor2d uses doc.getElById)\n//                 <OR>\n//               t: target => 'narrative'/'camera3d'/'camera2d'/'location', \n//               f: function 'shot', ...\n//                  or {}\n// Then action is executed as follows:\n// Mediator['camera3d'].actors('hamlet')[f](a);\n// The function 'f' created in broadcast (var f = new Function(...a);) is:\n//   var f = function(node){\n//           };\n//\n//  * NOTE: Mediator is used to fetch all component instances by name and \n//    so enables arbitrary inter-directive communications - not presently used\n//  * NOTE: Also implemented but not presently used is a broadcast and message\n//    system for trees of objects such as a 3D object hierarchy, especially\n//    created by the metaforms methodology.\n\n\nangular.module('app').factory('Mediator', [\"$rootScope\", \"$location\", \"Queue\", \"Camera3d\", \"Camera2d\", \"Models\", \"Mixin\", \"Transform3d\", \"Log\", \"config\", function($rootScope, $location,\n  Queue, Camera3d, Camera2d, Models, Mixin, Transform3d, Log, config){\n  'use strict';\n  var mediator,\n      log = Log.log,\n      components = {},\n      action,\n      pr;\n\n\n  class Mediator {\n    constructor(){\n      // first two vars are needed because injections are on stack - yes?\n      this.$rootScope = $rootScope; \n      this.location = $location; \n      this.mediator = this; \n      this.queue = Queue;\n      this.camera3d = Camera3d;\n      this.camera2d = Camera2d;\n      this.console = console;\n      this.narrative = undefined;\n      this.mixin = Mixin;              // unit test only\n      this.transform3d = Transform3d; // unit test only\n      this.config = config;\n      this.targets=['mediator', 'narrative', 'camera3d', 'camera2d'];\n      this.test_targets=['mixin', 'transform3d'];\n      this.record_stream = config.record_stream; \n      \n      // test target-refs\n      console.assert(this.mediator, \"this.mediator undefined!\");\n      console.assert(this.camera3d, \"this.camera3d undefined!\");\n      console.assert(this.camera2d, \"this.camera2d undefined!\");\n      console.assert(this.queue, \"this.queue undefined!\");\n      console.assert(this.mixin, \"this.mixin undefined!\");\n      console.assert(this.transform3d, \"this.transform3d undefined!\");\n\n\n      // pass refs to cameras amd Log\n      Log.set_mediator(this); \n      Camera3d.set_mediator(this);\n      Camera2d.set_mediator(this);\n\n      // start queue checks - LATER - much smaller interval\n      setInterval(() => {\n        if(mediator.queue.ready){\n          this.next();\n        }else{\n        }\n      }, 5000);\n    }\n\n\n    test(a){\n      if(Array.isArray(a)){\n      }else{\n      }\n    }\n\n\n    // connect to index.js server = config.server_host \n    // on port config.channels_port (default is 8081)\n    // NOTE: config is defined in index.html\n    connect(){\n      var s_h = config.server_host,\n          c_p = config.channels_port;\n      //Audio.speak(\"Mediator service trying to connect to server port 8081\");\n      this.socket = io.connect(\"http://\" + s_h + \":\" + c_p);\n      this.socket.on('actions', (action) => {\n        this.queue.push(action);\n      });\n    }\n\n    // broadcast usable by external services\n    emit(channel, msg){\n      // guard\n      if(config.channels_out.indexOf(channel) !== -1){\n        this.socket.emit(channel, msg);\n      }else{\n        return false;\n      }\n    }\n\n\n    // set queue.ready = true, and check queue for action\n    queue_ready_next(){\n      mediator.queue.ready = true;\n      mediator.next();\n    }\n      \n    // fetch next action from queue - removes action from queue\n    // if queue is empty returns undefined\n    next(){\n      action = mediator.queue.peek();\n      if(action){\n        action = mediator.queue.pop();\n        this.exec(action);\n        if(this.record_stream){\n          this.socket.emit('actions', action);\n        }\n      }\n    }\n\n\n\n    // register/fetch component controller-vm by id\n    component(id, cvm){\n\n      // fetch by name\n      if(cvm === undefined){\n        return components[id];\n      }\n\n      // set action target narrative\n      if(id === 'narrative'){\n        this.narrative = cvm;\n      }\n\n      // register cvm by directive id \n      if(components[id] === undefined){\n        components[id] = cvm;\n        cvm.predecessor = null;\n        cvm.enfants = [];\n        this.mixin.include(cvm, {\n          // get/set predecessor and enfants/child\n          parent(p){\n            if(p){\n              cvm.predecessor = p;\n            }else{\n              return cvm.predecessor;\n            }\n          },\n          children(child){\n            if(child){\n              cvm.enfants.push(child);\n            }else{\n              return cvm.enfants;\n            }\n          },\n\n          // send action to all descendants of cvm\n          // NOTE: arg to broadcast is array of 0 or more string-args to the\n          // function whose string-body is the final arg in array a\n          // NOTE: es6 ...a => destructure the array\n          broadcast(a){  \n            // NOTE: eval!\n            var f = new Function(...a);\n            var g = function(node){\n              f(node);\n              for(let e of node.enfants){\n                g(e);\n              }\n            };\n          },\n          // send action to all ancestors of cvm\n          emit(a){\n            // NOTE: eval!\n            var f = new Function(...a);\n            var g = function(node){\n              f(node);\n              if(node.parent){\n                g(node.predecessor);\n              }\n            };\n          }\n        });\n      }\n    }\n    \n\n    // record to server - used to record interactive camera shots to stream\n    record(action){\n      this.socket.emit('actions', action);\n    }\n\n\n    // message-based function invocation\n    // NOTE: if use 'id' instead of simple 't' then id\n    // can use a tuple structure with the form - id: 'type:id'\n    // exp: id: 'i2d:rect0'\n    // if id is simple such as id: 'cube0' then i3d is assumed\n    // and the target is Camera3d.actor(action.id)\n    exec(_action) {\n      var tuple,\n          actor,   // Camera3d.actor(action.id) or doc.getElById(action.id)\n          target,  // actor or mediator[action.t]\n          f,       // target[action.f]\n          execute = (action) => {\n\n            // Camera3d.actor(id).f or Mediator.target.f\n            if(action.id){             // @@@ id\n              tuple = action.id.split(':');\n              // i3d is default - get Camera3d.actor\n              // otherwise use document.getElementById\n              if(tuple.length === 1){\n                actor = Camera3d.actor(action.id);\n              }else{\n                if((tuple[0] === 'i3d') || (tuple[0].length === 0)){\n                  actor = Camera3d.actor(tuple[1]);\n                }else{\n                  if(tuple[1]){\n                    actor = document.getElementById(tuple[1]);\n                  }\n                }\n              }\n              \n              if(actor){\n                // unit test\n                if(config.unit_test){  // *** unit_test\n                  return actor;\n                }else{\n                  target = actor;      // target object for function f\n                  f = actor[action.f];\n                }\n              }else{\n                throw new Error(`Canera3d.actor(${action.id}) is not defined!`);\n              }\n            }else{                     // @@@ target-name, not id       \n              console.assert(mediator[action.t], \"mediator[action.t] UNDEFINED!\");\n              console.assert(mediator[action.t][action.f], \n                \"mediator[action.t][action.f] UNDEFINED!\");\n              if(mediator[action.t]){\n                if(mediator[action.t][action.f]){\n                  target = mediator[action.t];      // target\n                  f = target[action.f];\n                }else{\n                  throw new Error(`${action.t}.${action.f} is not defined!`);\n                }\n              }else{\n                throw new Error(`action target mediator.${action.t} not defined!`);\n              }\n            }\n\n\n            if(f){ \n              if(Array.isArray(action.a)){\n                // action.a is an array of args\n                switch(action.a.length){\n                  case 1:\n                    //f(action.a[0]) => 'this' UNDEFINED in target\n                    if(config.unit_test){\n                      return {a0: action.a[0]};\n                    }else{\n                      target[action.f](action.a[0]);\n                    }\n                    break;\n      \n                  case 2:\n                    //f(action.a[0], action.a[1]) => 'this' UNDEFINED in target\n                    if(config.unit_test){\n                      return {b0: action.a[0], b1:action.a[1]};\n                    }else{\n                      target[action.f](action.a[0], action.a[1]);\n                    }\n                    break;\n      \n                  case 3:\n                    //f(action.a[0], [1], [2]) => 'this' UNDEFINED in target\n                    if(config.unit_test){\n                      return {c0: action.a[0], c1:action.a[1], c2:action.a[2]};\n                    }else{\n                      target[action.f](action.a[0], action.a[1], action.a[2]);\n                    }\n                    break;\n      \n                  case 4:\n                    //f(action.a[0], [1], [2], [3]) => 'this' UNDEFINED in target\n                    if(config.unit_test){\n                      return {d0: action.a[0], d1:action.a[1], d2:action.a[2],\n                        d3:action.a[3]};\n                    }else{\n                      target[action.f](action.a[0], action.a[1], action.a[2], action.a[3]);\n                    }\n                    break;\n      \n                  default:\n                    //f(action.a) => 'this' UNDEFINED in target\n                    if(config.unit_test){\n                      return action.a\n                    }else{\n                      target[action.f](action.a);\n                    }\n                    throw new Error(`CAUTION: >4 args in array treated as one array!`);\n                }   \n              }else{\n                // action.a is a single value\n                if(config.unit_test){\n                  return action.a\n                }else{\n                  target[action.f](action.a);  // => 'this' defined in camera2d.zoomflyTo\n                }\n              }\n            }else{\n              if(action.id){\n                throw new Error(`actor(${action.id}).${action.f}) is not defined!`);\n              }else{\n                throw new Error(`${action.t}.${action.f} is not defined!`);\n              }\n            }\n          };//execute();\n\n      \n       if(Array.isArray(_action)){\n         for(let a of _action){              // _action is array\n           if(config.unit_test){            // *** unit_test\n             return execute(a);\n           }else{\n             execute(a);\n           }\n         }\n       }else{\n         // guard\n         if(!check.object(_action)){\n           console.log(\"!Mediator.emit(action - is NOT object)\");\n           Log.log({t:'!Mediator', f:'emit', a:'action - is NOT object'});\n           return;\n         }\n         // {1} log action - for building e2e_spec array\n         // NOTE: all shots exec {t:'Mediator', f:'queue_ready_next'}\n         // when completed to allow a new action to start - not helpful\n         // in constructing an e2e_spec\n         if(config.unit_test){\n           return execute(_action);\n         }else{\n           if(_action.f && (_action.f !== 'queue_ready_next')){ \n             Log.log(_action);\n           }\n           execute(_action);\n         }\n       }\n    }//exec\n  }//class Mediator\n\n\n\n  // return factory object\n  // (redundant) maintenance of Singleton\n  // create Mediator singleton instance once\n  // listen to 'actions' channel - push incoming actions to queue\n  // set cycle to pop actions from queue and execute them (& possibly record)\n  if(!mediator){\n    mediator = new Mediator(); \n  }\n\n\n  // return Mediator singleton instance\n  return mediator;  \n}]);\n\n"],"file":"services/mediator-service.js","sourceRoot":"/source/"}