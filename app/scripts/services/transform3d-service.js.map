{"version":3,"names":[],"mappings":"","sources":["services/transform3d-service.js"],"sourcesContent":["// * transform3d-service.js\n// * creates a transform matrix from a transform model.\n//\n// * @dependencies: Log<br>\n//   @param {app/services/log-service} Log<br>\n//   @ngInject\n//\n// * NOTE: ngInject is used by ngAnnotate to generate a \n//   minification-safe injection annotation such as:\n//   ```function($scope) => ['$scope', function($scope){}]```\n//\n// * transform model has form: transform:<br> \n// ```{t: [tx,ty,tz],\n//     q: [qx,qy,qz,qw],\n//     e: [ep,ey,er],\n//     s: [sx,sy,sz]}```\n// where t is translation, q is quaternion-rotation, e is euler-rotation\n// and s is scale.<br> \n// Each has canonical identity default<br>\n// At most one of q or e should be used \n//\n// * ```Transform3d.apply(transform, [actor])``` takes as first arg a (JSON.parsed)\n// transform model, i.e. a javascript object containing numeric arrays.<br>\n// A transform matrix is created and returned<br>\n// An optional second arg is a THREE.js Object3d on which the created\n// matrix is applied.\n//\n// * NOTE: mm = (new THREE.Matrix4()).set(e0,e1,...,e15) takes arguments in\n//   row-major order, i.e set(m11,m12,m13,m14,m21,...m44) (using math indices).\n//   However, when a matrix is decomposed into elements, for example,\n//   [a0,a1,a2,...,a15] = mm.elements, the a-array is in column-major order,\n//   i.e [m11,m21,m31,m41,m12,...m44] (using math indices).\n//   Thus [ei] !== [ai]\n\n\nangular.module('app').factory('Transform3d', [\"Log\", function(Log){\n  \"use strict\";\n\n  var transform3d;\n\n\n  class Transform3d {\n    constructor(){}\n\n    apply(transform, actor){\n      var m = new THREE.Matrix4(),  // identity matrix\n          mr = undefined,\n          mt = undefined,\n          ms = undefined;\n\n      // guard\n      if(!check.object(transform)){\n        console.log(\"!Transform3d.apply(transform - is NOT object)\");\n        Log.log({t:'!Transform3d', f:'apply', a:'transform - is NOT object'});\n        return m;\n      }\n\n\n      // transform matrix component matrices\n      if(transform['q']){\n        let qa = transform.q;\n        let q = new THREE.Quaternion(qa[0],qa[1],qa[2],qa[3]);\n        mr = (new THREE.Matrix4()).makeRotationFromQuaternion(q);\n      }\n      if(transform['e']){\n        let ea = transform.e;\n        let euler = new THREE.Euler(ea[0],ea[1],ea[2]); //default pyr (xyz)\n        mr = (new THREE.Matrix4()).makeRotationFromEuler(euler);\n      }\n      if(transform['t']){               \n        let ta = transform.t;\n        mt = (new THREE.Matrix4()).makeTranslation(ta[0],ta[1],ta[2]);\n      }\n      if(transform['s']){               \n        let sa = transform.s;\n        ms = (new THREE.Matrix4()).makeScale(sa[0],sa[1],sa[2]);\n      }\n\n      // * transform matrix - first scale, then rotate, then translate\n      // * NOTE: m = [mt*mr*ms], so m*v = mt*(mr*(ms*v)))\n      m = mt || m;\n      if(mr){\n        m = m.multiply(mr);\n      }\n      if(ms){\n        m = m.multiply(ms);\n      }\n\n      // if Object3d-actor is sent as second arg apply matrix to it\n      if(actor){\n        actor.applyMatrix(m);\n      }\n\n      // return created matrix representing model transform input\n      return m;\n    }\n\n    // for unit test verification - does m1 equal m2?\n    // careful of precision - .01 error is very generous\n    // * NOTE: m.elements is given in column-major!\n    //   Thus m[i][j].elements = [m00, m10, m20, m30, m01, m11, m21, m31, ...]\n    //                            column0           , column1 etc...\n    verify(m,mm){\n      var a = m.elements,\n          aa = mm.elements,\n          flag = true,\n          d = [],\n          sa = [],\n          i;\n      for(i=0; i<a.length; i++){\n        d[i] = Math.abs(a[i]-aa[i]);\n        sa.push(\"a[\"+i+\"]=\" + a[i] + \" aa[\" + i + \"]=\" + aa[i] + \" d[i]=\" + d[i]);\n        if(Math.abs(d[i]) > 0.01){\n          flag = false;\n          for(i=0; i<sa.length; i++){\n            console.log(\"error: \" + sa[i]);\n          }\n          break;\n        }\n      }\n      return flag;\n    }\n  }\n\n\n  // return factory object<br>\n  // (redundant) maintenance of Singleton\n  if(!transform3d){\n    transform3d = new Transform3d();  // create Transform3d singleton once\n  }\n  return transform3d;\n}]);\n\n\n\n"],"file":"services/transform3d-service.js","sourceRoot":"/source/"}